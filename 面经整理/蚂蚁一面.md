#### 1. jvm内存结构

#### 2. 三种classLoader以及其特性和功能

- 启动类加载器：**主要是加载jvm自身需要的类**，这个类加载使用C++语言实现，**它负责将JAVA_HOME/lib或-Xbootclasspath参数指定路径下的核心类库加载到内存中。**
- 扩展类加载器：由Java语言实现，是Launcher的静态内部类，**它负责加载JAVA_HOME/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库**，开发者可以直接使用标准扩展类加载器。
- 系统类加载器：**它负责加载系统类路径java -classpath或-D java.class.path指定路径下的类库**，也就是我们经常用的classpath路径，开发者可以直接使用系统类加载器，**一般情况下该类加载器是程序中默认的类加载器，通过ClassLoader#getSystemLoader()方法可以直接获取到该类加载器。**
- 双亲委派机制：双亲委派机制中的父子关系并不是通常所说的类继承关系，而是**采用组合关系**来复用父类加载器的相关代码**（组合和继承的比较、优缺点）**

#### 3. jvm调优参数、GC算法

- **-Xms -Xmx限定堆的最大、最小值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同值。**
- **-XX:newSize -XX:MaxNewSize设置新生代的绝对大小，为了防止新生代的堆收缩，同样将这两个值设置为同样大小。**
- **为老年代选择并行收集算法：-XX:+UserParallelOldGC**

#### 4. JDK6和JDK6以后的jvm变化

- 在JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代

  在JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代

  在JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace） 

#### 5. 线程安全怎么样发生（jmm角度）

#### 6. Class文件结构

- 魔数、次版本号、主版本号、常量池入口、访问标志、类索引、父类索引、接口索引、字段表集合、方法表集合、属性表集合

#### 7. MySQL索引、索引的原理、InnoDB和MyIsam区别、可重复读

#### 8. HashMap碰撞、树化实现

#### 9. concurrentHashMap为什么并发高

#### 10. 四种ThreadPool，如何配置参数

#### 11. tcp和udp区别、tcp丢包重传实现、三次握手（为什么）、滑动窗口、拥塞控制算法、tcp特性

- udp特点：无连接，尽最大努力交付，没有拥塞控制，因此出现拥塞不会使源主机的发送速率降低，面向报文，首部开销小。

- tcp特点：面向连接（在通信之前会建立一条虚拟链路），提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流，每一条tcp连接只能是点对点的。